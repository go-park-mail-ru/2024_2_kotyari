**Работа с БД через сервисную учетную запись**
=============================================

### Создание сервисной учетной записи

Скрипт для создания сервисной учетной записи находится в файле `service.sql`:

```sql
CREATE USER service_account WITH PASSWORD 'kotyari-Password123@';

GRANT CONNECT ON DATABASE kotyari_2024 TO service_account;

CREATE ROLE service_account_role WITH LOGIN;

GRANT USAGE ON SCHEMA public TO service_account_role;

GRANT SELECT ON ALL TABLES IN SCHEMA public TO service_account_role;
GRANT INSERT ON orders, product_orders, carts TO service_account_role;
GRANT UPDATE ON users, carts, products TO service_account_role;

GRANT service_account_role TO service_account;
```

В данном скрипте мы создали пользователя (учетную запись приложению), задали ему пароль и права на необходимые действия.

Далее необходимо было поменять настройки в конфигурации, в нашем случае в файле `.env`:

* Имя пользователя теперь `service_account`
* Пароль теперь `kotyari-Password123@`

Скрипт разместили в разделе миграций для упрощения контроля изменений.

### Защита от SQL Injections

Мы используем пакет "github.com/jackc/pgx/v5/pgxpool", он поддерживает Prepared Statement

Пример валидации можно посмотреть в файле delivery/profile/update_profile_data.go

Экранирование символов и предотвращение SQL-инъекций обеспечивается автоматически благодаря использованию подстановочных параметров (например, $1, $2, $3).
В библиотеке pgx параметры передаются отдельно от SQL-запроса, и библиотека автоматически экранирует значения, заменяя их эквивалентами в PostgreSQL.
Это позволяет избежать SQL-инъекций, так как данные пользователя не вставляются напрямую в текст запроса.

Пример:

```sql
	const query = `
		UPDATE users 
		SET email = $1, 
		    username = $2, 
		    gender = $3 
		WHERE id = $4;	
	`
```

### Пул соединений и параметры соединений

Мы реализовали connection pool на строне приложения с помощью библиотеки "github.com/jackc/pgx/v5/pgxpool"
Создание *pgxpool.Pool находится в файле internal/configs/postgres/init.go
Количество соединений defaultMaxConnections = 90 в connection pool
Создадим postgresql.conf
Количество соединений в connection pool и значение max_connections должны быть сбалансированы таким образом, 
что количество соединений на стороне приложения должно быть немного меньше, чем на стороне базы данных, поэтому поставим 100,
потому что нужно еще несколько соединений, например для администрирования.

Мы указали listen_addresses = 'localhost', потому что наши сервисы работают на одном сервере

### Настройка параметров сервера и клиента

statement_timeout — таймаут на каждое выражение;

lock_timeout — таймаут ожидания при получении блокировки (таблицы, строки или любого другого объекта БД);

Мы настроили statement_timeout = 10s
Современные пользователи не готовы долго ждать отклика. Значение выше может ухудшить UX. 
Для онлайн-магазина большая задержка может привести к потере клиента.
lock_timeout = 10s
Чтобы быстро завершать зависающие транзакции и снизить риск дедлоков.
Ограничение времени выполнения запросов полезно для защиты базы данных от тяжелых и долго выполняющихся запросов.
Это значение достаточно для корректных запросов и предотвращает избыточное потребление ресурсов при ошибках или злоумышленных действиях.